## 动态规划

这是一道经典的区间 DP 题。

**之所以可以使用区间 DP 进行求解，是因为在给定一个回文串的基础上，如果在回文串的边缘分别添加两个新的字符，可以通过判断两字符是否相等来得知新串是否回文。**

也就是说，使用小区间的回文状态可以推导出大区间的回文状态值。

**从图论意义出发就是，任何一个长度为 $len$ 的回文串，必然由「长度为 $len - 1$」或「长度为 $len - 2$」的回文串转移而来。**

**两个具有公共回文部分的回文串之间存在拓扑序（存在由「长度较小」回文串指向「长度较大」回文串的有向边）。**

通常区间 DP 问题都是，常见的基本流程为：

1. 从小到大枚举区间大小 $len$
2. 枚举区间左端点 $l$，同时根据区间大小 $len$ 和左端点计算出区间右端点 $r = l + len - 1$
3. 通过状态转移方程求 $f[l][r]$ 的值

因此，我们 **定义 $f[l][r]$ 为考虑区间 $[l, r]$ 的最长回文子序列长度为多少。**

不失一般性的考虑 $f[l][r]$ 该如何转移。

由于我们的状态定义 **没有限制** 回文串中必须要选 $s[l]$ 或者 $s[r]$。

我们对边界字符 $s[l]$ 和 $s[r]$ 分情况讨论，最终的 $f[l][r]$ 应该在如下几种方案中取 $max$ ：

* 形成的回文串一定不包含 $s[l]$ 和 $s[r]$，即完全不考虑 $s[l]$ 和 $s[r]$：
  $$
  f[l][r] = f[l + 1][r - 1]
  $$

* 形成的回文串可能包含 $s[l]$，但一定不包含 $s[r]$：

$$
f[l][r] = f[l][r - 1]
$$

* 形成的回文串可能包含 $s[r]$，但一定不包含 $s[l]$：

$$
f[l][r] = f[l + 1][r]
$$

* 形成的回文串可能包含 $s[l]$，也可能包含 $s[r]$，根据 $s[l]$ 和 $s[r]$ 是否相等：

$$
f[l][r] = \begin{cases}
f[l + 1][r - 1] + 2 & s[l] = s[r] \\
f[l + 1][r - 1] & s[l] \neq s[r] \\
\end{cases}
$$

需要说明的是，上述几种情况可以确保我们做到「不漏」，但不能确保「不重」，对于求最值问题，我们只需要确保「不漏」即可，某些状态重复参与比较，不会影响结果的正确性。

> 一些细节：我们需要特判掉长度为 $1$ 和 $2$ 的两种基本情况。当长度为 $1$ 时，必然回文，当长度为 $2$ 时，当且仅当两字符相等时回文。

代码：

* []

```Java
class Solution {
    public int longestPalindromeSubseq(String s) {
        int n = s.length();
        char[] cs = s.toCharArray();
        int[][] f = new int[n][n]; 
        for (int len = 1; len <= n; len++) {
            for (int l = 0; l + len - 1 < n; l++) {
                int r = l + len - 1;
                if (len == 1) {
                    f[l][r] = 1;
                } else if (len == 2) {
                    f[l][r] = cs[l] == cs[r] ? 2 : 1;
                } else {
                    f[l][r] = Math.max(f[l + 1][r], f[l][r - 1]);
                    f[l][r] = Math.max(f[l][r], f[l + 1][r - 1] + (cs[l] == cs[r] ? 2 : 0));
                }
            }
        }
        return f[0][n - 1];
    }
}
```

* 时间复杂度：$O(n^2)$
* 空间复杂度：$O(n^2)$

---

## 最后

**如果有帮助到你，请给题解点个赞和收藏，让更多的人看到 ~ ("▔□▔)/**

也欢迎你 [关注我](https://oscimg.oschina.net/oscnet/up-19688dc1af05cf8bdea43b2a863038ab9e5.png)（公主号后台回复「送书」即可参与长期看题解学算法送实体书活动）或 加入[「组队打卡」](https://leetcode-cn.com/u/ac_oier/)小群 ，提供写「证明」&「思路」的高质量题解。

所有题解已经加入 [刷题指南](https://github.com/SharingSource/LogicStack-LeetCode/wiki)，欢迎 star 哦 ~
