[TOC]
# 渲染流程

## 0. 每个子阶段都有其输入内容、处理阶段和输出内容

## 1. 构建DOM树

### 将HTML转换为浏览器能够理解的结构--DOM树

## 2. 样式计算（Recalculate style）

### 计算出DOM节点中每个元素的样式

### 三步来完成

- 把CSS转换为浏览器能理解的结构--styleSheets

	- css样式来源

		- 通过link标签引入的css
		- style内的CSS
		- 元素内联CSS

- 转换样式表中的属性值，使其标准化

	- em => px
	- red => rgb(255, 0, 0)
	- bold => 700

- 计算出DOM树中每个节点的具体样式

	- 继承规则

		- 每个DOM节点都包含父节点的样式，默认使用useragent样式

	- 层叠规则

		- 定义了如何处理来自于多个源的属性值
		- 层叠上下文

## 3. 布局阶段（Layout）

### 计算DOM树种可见元素的几何位置信息

- 两个任务

	- 创建布局树render tree（只包含可见元素）

		- 不可见元素：head标签和display:none的元素

	- 布局计算

## 4. 分层（Layer）

### 渲染引擎会为特定的节点生成专用的图层，并生成一棵对应的图层树(layer tree)。这些图层叠加后合成了最终的页面

### 通常情况下，并不是布局树的每一个节点都包含一个图层，如果一个节点没有对应的图层，那么这个节点就从属于父节点的图层

### 分层依据

- 拥有层叠上下文属性的元素会被提升为单独的一层

	- 明确定位的元素postion不为static且z-index不为auto
	- opacity不为1
	- filter等

- 需要裁减(clip)的地方也会被创建为图层

	- 滚动条

## 5. 图层绘制（Paint）

### 把一个图层的绘制拆分为许多很小的绘制指令，然后再把这些指令按照顺序组成一个待绘制列表

## 6. 分块（tiles）

### 视口

- 页面可能很大  用户看到的部分叫做视口
- 没有必要绘制所有图层内容  开销很大

### 图块(tile)

- 合成线程会将图层划分为图块，大小通常是256*256或512*512
- 合成线程会按照视口附近的图块来优先生成位图，实际生成位图的操作是由栅格化来完成的

## 7. 光栅化（raster）

### 将图块转换为位图，图块是栅格化最小的执行单位

### 渲染进程维护了一个栅格化的线程池，所有的栅格化都是在线程池内进行的

### 通常栅格化都会使用GPU来加速生成，叫做快速栅格化，生成的位图被保存在GPU内存中

## 8. 合成（composite）

### 所有图块都被光栅化后，渲染进程会生成绘制图块的命令--DrawQuad，然后将该命令提交给浏览器进程

## 9. 显示（display）

### 浏览器进程里有一个叫Viz的组件，用来接收DrawQuad命令，然后将页面内容绘制到内存中，最后再将内存显示到屏幕上。

## 合成

### css transform

### 在渲染进程的非主线程执行，大大提升效率

## 重绘

### 更新元素的绘制属性

- 背景颜色

### 省去了布局和分层阶段，效率稍高

## 重排

### 更新了元素的几何属性

### 开销最大

*XMind: ZEN - Trial Version*